# DTS_VBA Driver Design Document

## Overview

This document specifies the canonical driver API surface for the three primary integration domains: SAP2000, AutoCAD, and Database. Each driver provides a clean, defensive, minimal-side-effect interface with built-in dry-run support, error handling, and GUID mapping.

---

## Design Principles

### 1. Defensive Programming
- All public methods use `On Error GoTo` handlers
- Invalid inputs return safe defaults (Empty, Nothing, False, "")
- No silent failures - all errors logged to LibDTS_Logger
- Idempotent operations where possible

### 2. Dry-Run Support
- All write operations accept `Optional dryRun As Boolean = False`
- Dry-run mode validates inputs and logs intended actions without committing
- Returns would-be result identifiers (e.g., generated names)
- Useful for validation, testing, and preview

### 3. Options Pattern
- Complex operations accept option dictionaries or dedicated option objects
- Default options favor safety over convenience
- Options include: overwriteMapping, loggingLevel, retryCount, timeout

### 4. GUID-Centric Design
- Every element has a persistent GUID (generated by LibDTS_Base)
- GUID stored in element metadata (Comment/Notes field) when supported
- Fallback to auxiliary mapping file (JSON/SQLite) when metadata unavailable
- Mapping persisted via LibDTS_DriverDB

### 5. Late Binding
- Use Object types for external apps (AutoCAD, SAP2000)
- No early-bound references unless explicitly approved
- Better version compatibility and deployment flexibility

### 6. Minimal Dependencies
- Drivers depend only on: LibDTS_Base, LibDTS_Logger, Core objects
- No circular dependencies between drivers
- No shared mutable state

---

## LibDTS_DriverSAP - Detailed Specification

### Purpose
Provides canonical interface for SAP2000 structural analysis software integration. Handles connection management, model creation, result retrieval, and GUID synchronization.

### Module-Level Variables
```vba
Private m_SapObject As Object        ' SAP2000 application object
Private m_SapModel As Object         ' Active model object
Private m_IsConnected As Boolean     ' Connection state
Private m_ConnectionVersion As String ' Detected SAP version
Private m_LastError As String        ' Last error message
Private m_PointCache As Object       ' Dictionary: GUID -> SAP point name
Private m_FrameCache As Object       ' Dictionary: GUID -> SAP frame name
Private m_AreaCache As Object        ' Dictionary: GUID -> SAP area name
```

### Public Constants
```vba
Public Const DRIVER_NAME As String = "LibDTS_DriverSAP"
Public Const APP_NAME As String = "DTS_CORE"
Public Const DEFAULT_UNITS As Long = 5  ' kN_m_C

' SAP version ProgIDs in priority order
Public Const SAP_VERSIONS As String = "SAP2000v25,SAP2000v24,SAP2000v23,SAP2000v22,SAP2000v21,SAP2000v20"
```

---

### 1. CONNECTION MANAGEMENT

#### Connect()
```vba
' Connect to SAP2000 instance (attach to existing or start new)
' Returns: True if connected successfully
' Options: version = "auto" (detect), "v25", "v24", etc.
'          startNew = False (prefer existing), True (always start new)
Public Function Connect(Optional version As String = "auto", _
                        Optional startNew As Boolean = False) As Boolean
```

**Behavior:**
1. Check if already connected (m_IsConnected = True) → return True
2. If version="auto", iterate through SAP_VERSIONS array
3. Try GetObject(, "CSI.SAP2000.API.SapObject") for existing instance
4. If fail or startNew=True, try CreateObject and ApplicationStart
5. Set present units to DEFAULT_UNITS (kN_m_C)
6. Initialize caches (Dictionary objects)
7. Log connection success with version info
8. Set m_IsConnected = True and return True
9. On failure, log error, set m_LastError, return False

**Error Handling:**
- Catch connection failures gracefully
- Log specific error (missing SAP, version mismatch, licensing)
- Provide actionable message in m_LastError

**Testing:**
- Test with SAP running / not running
- Test with multiple SAP versions
- Test connection recovery after disconnect

---

#### Disconnect()
```vba
' Disconnect from SAP2000 and clean up resources
' Returns: True if disconnected successfully
' Options: saveModel = False (don't save), True (save before disconnect)
Public Function Disconnect(Optional saveModel As Boolean = False) As Boolean
```

**Behavior:**
1. If not connected (m_IsConnected = False) → return True
2. If saveModel=True, call m_SapModel.File.Save()
3. Set m_SapObject = Nothing, m_SapModel = Nothing
4. Clear all caches (Set to Nothing)
5. Set m_IsConnected = False
6. Log disconnect
7. Return True

**Error Handling:**
- Catch save failures, log warning but continue disconnect
- Always set m_IsConnected = False even on error

---

#### IsConnected()
```vba
' Check if currently connected to SAP2000
' Returns: True if active connection exists
Public Function IsConnected() As Boolean
```

**Behavior:**
1. Return m_IsConnected And Not (m_SapModel Is Nothing)
2. No error handling needed (simple check)

---

#### GetLastError()
```vba
' Get last error message from driver
' Returns: String describing last error, or "" if no error
Public Function GetLastError() As String
```

**Behavior:**
1. Return m_LastError
2. Optionally clear m_LastError after reading

---

### 2. MODELING OPERATIONS

#### PushPoint()
```vba
' Create or update a point in SAP model
' Returns: SAP point name (e.g., "1", "2") or "" on failure
' Options: dryRun = False (commit), True (validate only)
'          overwriteExisting = False (skip if exists), True (update)
'          tolerance = 0.01 (mm, for duplicate detection)
Public Function PushPoint(pt As clsDTSPoint, _
                          Optional dryRun As Boolean = False, _
                          Optional overwriteExisting As Boolean = False, _
                          Optional tolerance As Double = 0.01) As String
```

**Behavior:**
1. Validate inputs: IsConnected, pt not Nothing, pt.IsValid
2. Check GUID exists, if not generate via pt.Base.guid = LibDTS_Base.GenerateGUID()
3. Check if point already exists in SAP via GUID lookup (m_PointCache)
4. If exists and not overwriteExisting → return cached name
5. If dryRun=True → log "Would create point at (x,y,z)", return "DRY_RUN_P#"
6. Call m_SapModel.PointObj.AddCartesian(pt.X, pt.Y, pt.Z, pointName)
7. Store GUID in SAP comment: SetComment(pointName, "GUID:" & pt.Base.guid)
8. Cache mapping: m_PointCache.Add pt.Base.guid, pointName
9. Persist mapping via LibDTS_DriverDB.SetMappedElement
10. Log creation, return pointName

**Error Handling:**
- Invalid point → log error, return ""
- SAP API failure → log error with return code, return ""
- Update m_LastError with specific failure reason

**Required Core Object Shape:**
```vba
' clsDTSPoint must expose:
' - X As Double, Y As Double, Z As Double
' - Base As clsDTSElement (with .guid)
' - IsValid() As Boolean (check coordinates are numeric)
```

---

#### PushFrame()
```vba
' Create or update a frame element in SAP model
' Returns: SAP frame name (e.g., "1", "2") or "" on failure
' Options: dryRun, overwriteExisting, createPoints (auto-create points if missing)
Public Function PushFrame(frame As clsDTSFrame, _
                          Optional dryRun As Boolean = False, _
                          Optional overwriteExisting As Boolean = False, _
                          Optional createPoints As Boolean = True) As String
```

**Behavior:**
1. Validate inputs: IsConnected, frame not Nothing, frame.IsValid
2. Check/generate GUID
3. If createPoints=True, call PushPoint for frame.StartPoint and frame.EndPoint
4. Get point names: p1Name, p2Name (from cache or creation)
5. Check if frame exists via GUID lookup (m_FrameCache)
6. If exists and not overwriteExisting → return cached name
7. If dryRun=True → log "Would create frame P1-P2, section=...", return "DRY_RUN_F#"
8. Call m_SapModel.FrameObj.AddByPoint(p1Name, p2Name, frameName, frame.sectionName)
9. Store GUID: SetGUID or SetComment(frameName, "GUID:" & frame.Base.guid)
10. Set local axes if frame.angle <> 0
11. Cache mapping: m_FrameCache.Add frame.Base.guid, frameName
12. Persist mapping
13. Log creation, return frameName

**Error Handling:**
- Point creation failure → log error, return ""
- Invalid section → log warning, use default section, continue
- SAP API failure → log error, return ""

**Required Core Object Shape:**
```vba
' clsDTSFrame must expose:
' - StartPoint As clsDTSPoint, EndPoint As clsDTSPoint
' - sectionName As String
' - angle As Double (local axis rotation)
' - Base As clsDTSElement (with .guid)
' - IsValid() As Boolean
```

---

#### PushArea()
```vba
' Create or update an area element (slab/wall) in SAP model
' Returns: SAP area name or "" on failure
Public Function PushArea(area As clsDTSArea, _
                         Optional dryRun As Boolean = False, _
                         Optional overwriteExisting As Boolean = False, _
                         Optional createPoints As Boolean = True) As String
```

**Behavior:**
1. Similar to PushFrame
2. Extract boundary points from area.BoundaryPoints (Collection of clsDTSPoint)
3. Create points via PushPoint
4. Call m_SapModel.AreaObj.AddByPoint(numPoints, pointNames(), areaName)
5. Set section property: SetProperty(areaName, area.sectionName)
6. Store GUID and cache mapping

**Required Core Object Shape:**
```vba
' clsDTSArea must expose:
' - BoundaryPoints As Collection (of clsDTSPoint)
' - sectionName As String
' - Base As clsDTSElement (with .guid)
' - IsValid() As Boolean (min 3 points, closed polygon)
```

---

#### PushRebar()
```vba
' Future: Create rebar element in SAP (if supported by SAP version)
' Returns: SAP object name or "" if not supported
Public Function PushRebar(rebar As clsDTSRebar, _
                          Optional dryRun As Boolean = False) As String
```

**Behavior:**
1. Check SAP version supports rebar (v22+)
2. If not supported, log warning, return ""
3. Otherwise similar pattern to PushFrame/PushArea

---

### 3. READING OPERATIONS

#### ReadPoint()
```vba
' Read a point from SAP model and hydrate clsDTSPoint object
' Returns: clsDTSPoint object or Nothing on failure
Public Function ReadPoint(pointName As String) As clsDTSPoint
```

**Behavior:**
1. Validate IsConnected
2. Call m_SapModel.PointObj.GetCoordCartesian(pointName, x, y, z)
3. Create new clsDTSPoint: Set pt = New clsDTSPoint
4. pt.Init x, y, z
5. Read GUID from comment/metadata
6. pt.Base.guid = extracted GUID
7. Return pt

**Error Handling:**
- Point not found → log warning, return Nothing
- Invalid coordinates → log error, return Nothing

---

#### ReadFrame()
```vba
' Read a frame from SAP model and hydrate clsDTSFrame object
' Returns: clsDTSFrame object or Nothing on failure
Public Function ReadFrame(frameName As String) As clsDTSFrame
```

**Behavior:**
1. Validate IsConnected
2. Get frame points: GetPoints(frameName, p1Name, p2Name)
3. Read point coordinates via ReadPoint
4. Get section: GetSection(frameName, sectionName, ...)
5. Get local axes: GetLocalAxes(frameName, angle, ...)
6. Create clsDTSFrame: Set frame = New clsDTSFrame
7. Set properties from SAP data
8. Read GUID from metadata
9. Return frame

---

#### ReadArea()
```vba
' Read an area from SAP model and hydrate clsDTSArea object
' Returns: clsDTSArea object or Nothing on failure
Public Function ReadArea(areaName As String) As clsDTSArea
```

**Behavior:**
1. Get area points: GetPoints(areaName, numPoints, pointNames())
2. Read all point coordinates
3. Get section property
4. Create clsDTSArea and populate
5. Read GUID from metadata
6. Return area

---

### 4. GUID MAPPING OPERATIONS

#### MapGUIDToElement()
```vba
' Explicitly map a GUID to SAP element name
' Returns: True if mapping created/updated successfully
Public Function MapGUIDToElement(guid As String, _
                                 sapName As String, _
                                 elementType As String) As Boolean
```

**Behavior:**
1. Validate inputs (guid not empty, sapName exists in model)
2. Store in appropriate cache (m_PointCache, m_FrameCache, m_AreaCache)
3. Persist via LibDTS_DriverDB.SetMappedElement
4. Try write GUID to SAP metadata if possible
5. Log mapping, return True

**Error Handling:**
- Invalid GUID format → log error, return False
- Element doesn't exist → log error, return False

---

#### FindElementByGUID()
```vba
' Find SAP element name by GUID
' Returns: SAP element name or "" if not found
Public Function FindElementByGUID(guid As String) As String
```

**Behavior:**
1. Search all caches (points, frames, areas)
2. If found, return cached name
3. If not found, scan SAP model comments/metadata (expensive)
4. Update cache if found via scan
5. Return name or ""

---

#### RemoveGUIDMapping()
```vba
' Remove GUID mapping (cleanup orphaned entries)
' Returns: True if removed successfully
Public Function RemoveGUIDMapping(guid As String) As Boolean
```

**Behavior:**
1. Remove from all caches
2. Remove from persistent storage via LibDTS_DriverDB
3. Log removal, return True

---

### 5. RESULTS QUERY OPERATIONS

#### GetFrameForces()
```vba
' Get frame forces for specified load case
' Returns: Dictionary with keys: "P", "V2", "V3", "T", "M2", "M3" or Nothing on failure
Public Function GetFrameForces(frameName As String, _
                               loadCase As String, _
                               Optional station As Double = 0#) As Object
```

**Behavior:**
1. Validate IsConnected, frameName exists
2. Call m_SapModel.Results.Setup.DeselectAllCasesAndCombosForOutput()
3. Call m_SapModel.Results.Setup.SetCaseSelectedForOutput(loadCase)
4. Call m_SapModel.FrameObj.GetElementForces(frameName, ...)
5. Parse results array into Dictionary
6. Return Dictionary or Nothing

**Error Handling:**
- Load case doesn't exist → log error, return Nothing
- Frame not analyzed → log warning, return empty Dictionary

---

#### GetAreaStresses()
```vba
' Get area stresses for specified load case
' Returns: Dictionary with stress components or Nothing on failure
Public Function GetAreaStresses(areaName As String, _
                                loadCase As String) As Object
```

**Behavior:**
1. Similar to GetFrameForces
2. Call m_SapModel.AreaObj.GetStress(...)
3. Parse to Dictionary
4. Return Dictionary or Nothing

---

### 6. UTILITY OPERATIONS

#### ClearCache()
```vba
' Clear all internal GUID caches
' Useful after model changes or before re-scan
Public Sub ClearCache()
```

**Behavior:**
1. Set m_PointCache = New Scripting.Dictionary
2. Set m_FrameCache = New Scripting.Dictionary
3. Set m_AreaCache = New Scripting.Dictionary
4. Log cache clear

---

#### RebuildCacheFromModel()
```vba
' Scan entire SAP model and rebuild GUID cache from metadata
' Returns: Number of elements cached
Public Function RebuildCacheFromModel() As Long
```

**Behavior:**
1. Call ClearCache
2. Get all point names, scan comments for GUIDs, populate m_PointCache
3. Get all frame names, scan comments for GUIDs, populate m_FrameCache
4. Get all area names, scan comments for GUIDs, populate m_AreaCache
5. Persist updated mapping
6. Log count, return total count

---

## Error Codes and Return Values

### Success Indicators
- Boolean functions: True = success, False = failure
- String functions: Non-empty string = success, "" = failure
- Object functions: Valid object = success, Nothing = failure

### Error Information
- GetLastError() provides details on most recent failure
- All errors logged to LibDTS_Logger with context
- Use DTS_ERROR log level for failures, DTS_WARNING for soft failures

---

## Options Pattern Example

For complex operations, use option dictionaries:

```vba
Dim options As Object
Set options = CreateObject("Scripting.Dictionary")
options.Add "dryRun", True
options.Add "overwriteExisting", False
options.Add "createPoints", True
options.Add "loggingLevel", DTS_INFO
options.Add "retryCount", 3
options.Add "timeout", 30  ' seconds

Dim frameName As String
frameName = LibDTS_DriverSAP.PushFrameEx(frame, options)
```

---

## Testing Strategy

### Unit Tests (Manual)
1. Connection tests: Connect with/without SAP running
2. Push tests: Create points, frames, areas in empty model
3. Read tests: Read back created elements, verify data integrity
4. GUID tests: Verify mapping persistence across sessions
5. Dry-run tests: Verify no changes made in dry-run mode

### Integration Tests
1. Round-trip: CAD → SAP → CAD, verify data integrity
2. Conflict resolution: Create duplicate elements, verify handling
3. Error recovery: Disconnect during operation, verify cleanup

### Smoke Tests
1. Quick sanity: Connect, create frame, read back, disconnect
2. Run before each release

---

## Migration Examples

### Before (Legacy Code):
```vba
' m01_SAP2000_Connection.bas
Public Function ConnectSAP2000() As Boolean
    Set SapApp = GetObject(, "CSI.SAP2000.API.SapObject")
    Set SapModel = SapApp.SapModel
    ConnectSAP2000 = Not (SapModel Is Nothing)
End Function

' m04_SAP2000_Joints_Frames.bas
Public Sub ExtractFrames()
    ret = SapModel.frameObj.GetNameList(gFrameCount, gFrameNames)
    ' ... populate global arrays
End Sub
```

### After (Driver-based):
```vba
' Using LibDTS_DriverSAP
Public Function ConnectToSAP() As Boolean
    ConnectToSAP = LibDTS_DriverSAP.Connect()
    If Not ConnectToSAP Then
        MsgBox LibDTS_DriverSAP.GetLastError(), vbCritical
    End If
End Function

Public Sub LoadFrames()
    Dim frames As Collection
    Set frames = LibDTS_DriverSAP.ReadAllFrames() ' Future: batch read
    
    Dim frame As clsDTSFrame
    For Each frame In frames
        ' Process frame object
    Next frame
End Sub
```

---

## Next Document: LibDTS_DriverCAD Specification

See `DOCS_DRIVER_CAD.md` for detailed AutoCAD driver specification.

---

**Document Version:** 1.0  
**Date:** 2025-11-23  
**Author:** DTS Consolidation Agent
